---
title: "Создание простых матриц пространственных весов для российских регионов"
output: github_document
---

В этом примере я показываю, как можно быстро создать матрицы пространственных весов для российских регионов. Такие матрицы могут понадобиться для анализа пространственной корреляции или применения методов пространственной эконометрики. 

## Загрузка пакетов

Для начала установим и загрузим пакеты, необходимые для пространственного анализа. 

```{r}
library(tidyverse)    # манипуляции с данными и визуализация
library(geodata)      # для доступа к данным о границах
library(sp)           # манипуляции с пространственными объектами
library(spdep)        # манипуляции с пространственными объектами
library(sf)           # манипуляции с пространственными объектами

sf_use_s2(FALSE)      # исправляет некоторые ошибки https://gis.stackexchange.com/questions/404385/r-sf-some-edges-are-crossing-in-a-multipolygon-how-to-make-it-valid-when-using
```

## Пространственные данные

Для осуществления пространственного анализа нам для начала нужны геоданные. Я буду использовать функцию из пакета `geodata` для доступа к данным с сайта GADM: <https://gadm.org/data.html> версии 3.6. На самом сайте есть более новые версии в разных форматах, но я привык к этой. Подробнее о форматах: <https://gadm.org/formats.html>.

Загрузим геоданные о российских регионах (для уровня регионов указываем `level = 1`): 

```{r}
rus_reg_gpkg <- geodata::gadm(country = 'RUS', level = 1, path = tempdir(), version = 3.6)
glimpse(rus_reg_gpkg)
```

Перейдем к другому формату, чтобы можно было использовать возможности пакета `sf`: 

```{r}
rus_reg_sf <- sf::st_as_sf(rus_reg_gpkg)
glimpse(rus_reg_sf)
```

Теперь мы работаем с набором данных, в котором содержатся различные пространственные данные. Колонки `NAME_1`, `NL_NAME_1` содержат названия регионов на латинице и на русском соответственно. И те, и другие не совсем соответствуют официальным названиям регионов РФ, но что-то нам нужно будет использовать для объединения с экономическими данными по регионам. Я для этого возьму колонку `NAME_1` для воспроизводимости в международном контексте и лучшей читаемости иностранными коллегами. 

Колонка `geometry` содержит координаты для построения мультиполигонов. Эти данные позволяют строить карты. 


Из-за расположения территории России в двух полушариях карта выглядит не очень корректно: 

```{r}
plot(st_geometry(rus_reg_sf))
```

Исправим проблему с координатной системой: 

```{r}
rus_reg_sf <- sf::st_transform(rus_reg_sf, crs = "+proj=longlat +lon_wrap=180")
```

Теперь получается адекватная карта: 

```{r}
 plot(st_geometry(rus_reg_sf))
```

## Создание матриц пространственных весов

Для создания матриц нам нужно преобразовать данные в ещё один формат ("Large SpatialPolygonDataFrame"): 

```{r}
rus_reg_poly <- sf::as_Spatial(rus_reg_sf)
str(rus_reg_poly, max.level = 2)
```

### Матрица весов, основанная на обратных расстояниях

Для начала создадим матрицу обратных расстояний между географическими центроидами регионов. Бывают и более продвинутые матрицы расстояний, в частности, основанные на расстояниях по дорогам между столицами регионов, но для их создания нужны дополнительные данные. А матрицу расстояний между центроидами можно создать автоматически из загруженных геоданных. 

Сначала создадим матрицу расстояний: 

```{r}
coords <- sp::coordinates(rus_reg_poly)
dist_mat <- sp::spDists(coords, longlat = TRUE) #	find Euclidean distance between points
```

Теперь на её основе создадим матрицу обратных расстояний. По главной диагонали этой матрицы должны стоять нули, а вне диагонали --- обратные расстояния. 

```{r}
inv_dist_mat <- 1 / dist_mat
diag(inv_dist_mat) <- 0
```

Матрица обратных расстояний готова, однако напрямую в анализе редко используют. Поэтому проведем ещё пару преобразований: 

```{r}
inv_dist_lw <- spdep::mat2listw(inv_dist_mat, row.names = rus_reg_poly$NAME_1, style = "W")
inv_dist_w_mat <- spdep::listw2mat(inv_dist_lw)
```

`inv_dist_lw` --- это список, содержащий в себе различные геоданные: он может понадобиться при работе с пространственными пакетами. 
`inv_dist_w_mat` --- матрица весов, основанная на обратных расстояниях. В отличие от исходной матрицы `inv_dist_mat`, она является нормализованной по строкам, т. е. сумма каждой строки равна единице, что обычно принято в пространственном анализе. 

```{r}
sum(inv_dist_w_mat[1, ])
sum(inv_dist_w_mat)
```

### Матрица весов, основанная на соседстве

Теперь построим матрицу весов, основанную на соседстве, т. е. наличии общих границ. 
Сначала создадим список с информацией о списке соседей каждого региона. Это может занять некоторое время. 

```{r}
rus_reg_nb <- spdep::poly2nb(rus_reg_poly)
```

С использованием этого объекта можно создавать матрицы весов. Но у него есть одна проблема: у Калиниградской и Сахалинской областей нет общих границ с другими российскими регионами. 

```{r}
summary(rus_reg_nb)
rus_reg_nb[[21]]
rus_reg_nb[[61]]
rus_reg_sf[c(21, 61), "NAME_1"]
```

Для исправления этой проблемы я использую функцию, найденную [здесь](https://stackoverflow.com/questions/57269254/how-to-impute-missing-neighbours-of-a-spatial-weight-matrix-queen-contiguity). Для регионов без соседей функция назначает соседом ближайшего по расстояниям между центроидами. 

```{r}
addnbs <- function(sp.sample){
  
  queen_nb <- poly2nb(sp.sample, row.names = sp.sample$ID, queen = TRUE)
  
  count = card(queen_nb)
  if (!any(count == 0)) {
    return(queen_nb)
  }
  
  ## get nearest neighbour index, use centroids:
  nnbs = knearneigh(coordinates(sp.sample))$nn
  
  no_edges_from = which(count == 0)
  for (i in no_edges_from) {
    queen_nb[[i]] = nnbs[i]
  }
  return(queen_nb)
}
```

```{r}
rus_reg_nb_fix <- addnbs(rus_reg_poly)
```

Теперь у всех есть соседи: 

```{r}
summary(rus_reg_nb_fix)
```

Как видим, соседом для Калининградской области "назначена" Псковская область, а для Сахалинской области --- Хабаровский край, что выглядит разумно. 

```{r}
rus_reg_nb_fix[[21]]
rus_reg_nb_fix[[61]]
rus_reg_sf[c(57, 28), "NAME_1"]
```

Теперь можем создать список с весами и нормализованную по строкам матрицу весов. 

```{r}
contig_lw <- spdep::nb2listw(rus_reg_nb_fix,  zero.policy = T) 
contig_w_mat <- spdep::listw2mat(contig_lw)
```

```{r}
sum(contig_w_mat[1, ])
sum(contig_w_mat)
```




